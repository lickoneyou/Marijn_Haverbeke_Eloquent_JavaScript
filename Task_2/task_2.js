// Минимум
// В предыдущей главе была упомянута функция Math.min,
// возвращающая самый маленький из аргументов. Теперь
// мы можем написать такую функцию сами. Напишите
// функцию min, принимающую два аргумента, и
// возвращающую минимальный из них.

// console.log(min(0, 10));
// // → 0
// console.log(min(0, -10));
// // → -10

function min(a, b) {
  return a > b ? b : a;
}

console.log(min(0, 10));
// → 0
console.log(min(0, -10));
// → -10

// Рекурсия
// Мы видели, что оператор % (остаток от деления) может
// использоваться для определения того, чётное ли число (
// % 2). А вот ещё один способ определения:
// Ноль чётный.
// Единица нечётная.
// У любого числа N чётность такая же, как у N - 2.
// Напишите рекурсивную функцию isEven согласно этим
// правилам. Она должна принимать число и возвращать
// булевское значение.
// Функции
// 103
// Потестируйте её на 50 и 75. Попробуйте задать ей -1.
// Почему она ведёт себя таким образом? Можно ли её както исправить?

// console.log(isEven(50));
// // → true
// console.log(isEven(75));
// // → false
// console.log(isEven(-1));
// // → ??

function isEven(n) {
  if (n == 0) {
    return true;
  }
  if (Math.abs(n) == 1) {
    return false;
  }
  return isEven(Math.abs(n) - 2);
}

console.log(isEven(50));
// → true
console.log(isEven(75));
// → false
console.log(isEven(-1));
// → ??

// Считаем бобы
// Символ номер N строки можно получить, добавив к ней
// .charAt(N) ( "строчка".charAt(5) ) – схожим образом с
// получением длины строки при помощи .length.
// Возвращаемое значение будет строковым, состоящим из
// одного символа (к примеру, "к"). У первого символа строки
// позиция 0, что означает, что у последнего символа
// позиция будет string.length - 1. Другими словами, у строки
// из двух символов длина 2, а позиции её символов будут 0
// и 1.
// Напишите функцию countBs, которая принимает строку в
// качестве аргумента, и возвращает количество символов
// “B”, содержащихся в строке.
// Функции
// 104
// Затем напишите функцию countChar, которая работает
// примерно как countBs, только принимает второй параметр
// — символ, который мы будем искать в строке (вместо
// того, чтобы просто считать количество символов “B”). Для
// этого переделайте функцию countBs.

function countBs(str) {
  return str.replace(/[^B]/g, "").length;
}

console.log(countBs("asdBBsdaBdB"));

function countChar(str, s) {
    let reg = new RegExp(`[^${s}]`, 'g')
    return str.replace(reg, "").length;
}

console.log(countChar("asdBaBasdABdB", 'B'));
